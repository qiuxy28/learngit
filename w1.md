## 解释下列术语

定点数：小数点位置约定在**固定位置**的数。

浮点数：小数点位置约定为**可浮动**的数。

补码：正数的**补码**符号为0，数值部分是它本身；负数的**补码**等于模与该负数绝对值之差。
$$
数X_T的补码用公式表示为：[X_T]=M+X_T(modM)
\\
$$
溢出：两个n位二进制数在进行运算过程中，可能会产生一个多余n位的结果，当剩下的低n位数不能正确表示运算结果，也即丢掉的高位是运算结果的一部分的情况，称为**溢出**现象。

上溢：对于浮点数计算机，不论数的符号是正还是负，若阶码从正的方向超出了阶码的表示范围，称为**上溢**。对于定点数计算机，从正方向超过了数的表示范围，成为**上溢**。

下溢：对于浮点数计算机，若阶码从负的方向超出阶码的表示范围，或者尾数为“0”时，统称为**下溢**。对于定点数计算机，成为**下溢**。

SRAM

DRAM

## 用16位补码计算

$$
\textbf{167+231:}
\\
[167]_补=2^{16}+167(mod\ 2^{16})=0000\ 0000\ 1010\ 0111
\\
[231]_补=2^{16}+231(mod\ 2^{16})=0000\ 0000\ 1110\ 0111
\\
[167+231]_补=[167]_补+[231]_补=0000\ 0000\ 1010\ 0111+0000\ 0000\ 1110\ 0111
\\
=0000\ 0001\ 1000\ 1110
\\
所以167+231=0000\ 0001\ 1000\ 1110
$$

$$
\textbf{231-167:}
\\
[-167]_补=2^{16}-167(mod\ 2^{16})=1111\ 1111\ 0101\ 1001
\\
[231]_补=2^{16}+231(mod\ 2^{16})=0000\ 0000\ 1110\ 0111
\\
[231-167]_补=[231]_补+[-167]_补=0000\ 0000\ 1110\ 0111+1111\ 1111\ 0101\ 1001
\\
=1\ 0000\ 0000\ 0100\ 0000(mod\ 2^{16})=0000\ 0000\ 0100\ 0000
\\
所以231-167=0000\ 0000\ 0100\ 0000
$$

## 用IEEE754标准的浮点数描述如下数字

$$
\textbf{189.125:}
\\
189.125=(10111101.001)_2=0\ 1.0111101001*2^{111}
\\
=0\ 111\ 0111101001
$$

$$
\textbf{156.5:}\\
156.5=(10011100.1)_2=0\ 1.00111001*2^{111}\\
=0\ 111\ 00111001
$$

$$
\textbf{231.25:}\\
156.5=(11100111.01)_2=0\ 1.110011101*2^{111}\\
=0\ 111\ 110011101
$$



## 说明指令执行过程的步骤

一个CPU指令的执行过程可以分成4各阶段：取指、译码、执行、回写。

第一步：取指

CPU控制电路通过内部总线把PC传递到MAR，MAR通过地址总线将指令地址传递到存储器MAR，存储器最后将指令地址对应数据通过数据总线传递到CPU的MDR，最后CPU将MDR的内容存储到CIR中，PC指向下一个要执行指令的地址。

第二步：译码

CIR中的指令通过内部总线传输到指令译码器翻译成需要执行的代码

第三步：执行

以下图为例，通过译码得到指令为“LOAD 10”,加载内存地址10（00001010）的数据，这一步过程类似于取指。

<img src="C:\Users\qiuxy\learngit\cpusim.png" style="zoom:30%;" />

第四步：回写

执行完上一步的汇编代码，将计算结果写入对应位置的缓存中。



